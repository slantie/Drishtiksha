// prisma/schema.prisma

// =============================================================================
// Drishtiksha Backend - Final Refactored Database Schema v3.0
// =============================================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


// =============================================================================
// CORE MODELS
// =============================================================================

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  firstName String
  lastName  String
  password  String
  role      Role     @default(USER)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  media Media[]

  @@map("users")
}


model Media {
  id          String      @id @default(uuid())
  filename    String
  url         String
  publicId    String      // The ID used by the storage provider (e.g., Cloudinary public_id)
  mimetype    String
  size        Int
  description String?
  status      MediaStatus @default(QUEUED) // Represents the status of the LATEST run
  mediaType   MediaType
  userId      String
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  
  // A single media file can have multiple "runs" of the analysis pipeline over time.
  analysisRuns AnalysisRun[]

  // A direct link to the ID of the *most recent* analysis run.
  // This is a performance optimization for quickly fetching the latest result.
  latestAnalysisRunId String?

  @@index([userId, createdAt(sort: Desc)])
  @@map("media")
}


// =============================================================================
// ANALYSIS & VERSIONING MODELS
// =============================================================================

// Represents a single, user-initiated execution of the multi-model analysis workflow.
model AnalysisRun {
  id        String   @id @default(uuid())
  mediaId   String
  media     Media    @relation(fields: [mediaId], references: [id], onDelete: Cascade)
  
  // A simple, user-facing version number (Run 1, Run 2, etc.).
  runNumber Int
  
  // The overall status of this entire run.
  status    MediaStatus @default(QUEUED)
  
  // When this specific run was initiated by the user.
  createdAt DateTime @default(now())
  
  // Each run is composed of multiple individual model analyses.
  analyses  DeepfakeAnalysis[]

  // A unique constraint to ensure run numbers are sequential per media item.
  @@unique([mediaId, runNumber])
  @@map("analysis_runs")
}


// Represents the result from a SINGLE model for a given AnalysisRun.
model DeepfakeAnalysis {
  id              String   @id @default(uuid())
  analysisRunId   String
  analysisRun     AnalysisRun @relation(fields: [analysisRunId], references: [id], onDelete: Cascade)
  
  // Top-level, queryable fields for quick access and filtering.
  modelName       String
  prediction      String
  confidence      Float
  status          AnalysisStatus @default(PENDING)
  errorMessage    String?
  
  // The core of our new, decoupled strategy.
  // The entire rich, structured JSON response from the Python server's 'data' field
  // is stored here. This makes the backend future-proof.
  resultPayload   Json
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("deepfake_analyses")
}


// =============================================================================
// MONITORING MODELS
// =============================================================================

model ServerHealth {
  id              String   @id @default(uuid())
  status          String   // e.g., "HEALTHY", "UNHEALTHY"
  responseTimeMs  Int
  
  // The full, rich JSON response from the Python server's /stats endpoint.
  // This allows us to build powerful monitoring dashboards without needing to
  // change the schema every time the server adds a new statistic.
  statsPayload    Json
  
  checkedAt       DateTime @default(now())

  @@map("server_health")
}


// =============================================================================
// ENUMS
// =============================================================================

enum Role {
  USER
  ADMIN
}

enum MediaStatus {
  QUEUED
  PROCESSING
  ANALYZED
  FAILED
}

enum AnalysisStatus {
  PENDING
  COMPLETED
  FAILED
}

enum MediaType {
  VIDEO
  IMAGE
  AUDIO
  UNKNOWN // Fallback for unsupported types
}