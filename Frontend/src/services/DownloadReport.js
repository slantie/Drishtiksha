// src/services/DownloadReport.js

import html2pdf from "html2pdf.js";
import { showToast } from "../utils/toast.jsx"; // Import toast for user feedback
import {
  formatBytes,
  formatDate,
  formatProcessingTime,
} from "../utils/formatters.js"; // Centralize formatters

/**
 * @file Service for generating and downloading video analysis reports.
 * This version focuses on creating a high-fidelity, A4-formatted report
 * that looks professional both on-screen and when printed, aligning with the new backend schema.
 */

//================================================================================================
// CONFIGURATION
//================================================================================================

const ReportConfig = {
  brandName: "Drishtiksha",
  mainTitle: "Media Analysis Report", // Changed to Media Analysis
  // Icons
  icons: {
    real: "✅",
    fake: "⚠️",
    info: "ℹ️",
    summary: "📊",
    details: "🔍",
    error: "❌", // Updated icon for error
  },
  // Colors
  colors: {
    primary: "#8155c6", // Match new primary color
    authentic: "#16a34a",
    deepfake: "#dc2626",
    textPrimary: "#1B1B1F", // Match dark mode primary text
    textSecondary: "#3C3C43", // Match light mode primary text
    textMuted: "#67676C", // Match light mode muted text
    background: "#FFFFFF",
    border: "#EBEBEF", // Match light mode secondary border
    pageBackground: "#f9fafb", // Slightly off-white
  },
};

//================================================================================================
// PRIVATE HELPERS & DATA PROCESSING
//================================================================================================

const prepareReportData = (media, user) => {
  // Media object from frontend will have analysisRuns
  const latestAnalysisRun = media.analysisRuns?.[0]; // Get the latest run

  let completedAnalyses = [];
  let failedAnalyses = [];
  if (latestAnalysisRun) {
    completedAnalyses =
      latestAnalysisRun.analyses?.filter((a) => a.status === "COMPLETED") || [];
    failedAnalyses =
      latestAnalysisRun.analyses?.filter((a) => a.status === "FAILED") || [];
  }

  const realDetections = completedAnalyses.filter(
    (a) => a.prediction === "REAL"
  ).length;
  const fakeDetections = completedAnalyses.filter(
    (a) => a.prediction === "FAKE"
  ).length;
  const totalAnalyses = completedAnalyses.length + failedAnalyses.length;

  let overallAssessment = "Inconclusive";
  let assessmentColor = ReportConfig.colors.textMuted;
  if (fakeDetections > realDetections) {
    overallAssessment = "Likely Deepfake";
    assessmentColor = ReportConfig.colors.deepfake;
  } else if (realDetections > fakeDetections) {
    overallAssessment = "Likely Authentic";
    assessmentColor = ReportConfig.colors.authentic;
  } else if (totalAnalyses === 0 && media.status === "FAILED") {
    overallAssessment = "Analysis Failed";
    assessmentColor = ReportConfig.colors.deepfake;
  } else if (totalAnalyses === 0 && media.status === "QUEUED") {
    overallAssessment = "Pending Analysis";
    assessmentColor = ReportConfig.colors.textMuted;
  }

  return {
    ...media,
    user, // Include user for 'Generated By' section
    latestAnalysisRun,
    completedAnalyses,
    failedAnalyses,
    realDetections,
    fakeDetections,
    totalAnalyses,
    overallAssessment,
    assessmentColor,
  };
};

//================================================================================================
// HTML STYLING (CSS)
//================================================================================================

const getReportStyles = () => `
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap');
        @page { size: A4; margin: 0; }

        body {
            -webkit-print-color-adjust: exact;
            color-adjust: exact;
            background-color: ${ReportConfig.colors.pageBackground};
            font-family: 'Poppins', sans-serif;
            font-size: 10pt; /* Slightly smaller base font for A4 */
            line-height: 1.5;
            color: ${ReportConfig.colors.textPrimary};
            margin: 0;
            padding: 1.5rem 0; /* Reduced padding */
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .page {
            width: 210mm;
            min-height: 297mm;
            padding: 18mm 16mm; /* Reduced padding */
            background: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08); /* Lighter shadow */
            margin-bottom: 1.5rem; /* Reduced margin */
            page-break-after: always;
            box-sizing: border-box; /* Ensure padding is included in width/height */
        }
        .page:last-of-type {
            page-break-after: auto;
            margin-bottom: 0;
        }

        h1, h2, h3, h4 { font-weight: 600; color: ${ReportConfig.colors.textPrimary}; line-height: 1.2; margin-bottom: 0.5em; }
        h1 { font-size: 20pt; margin-top: 0; } /* Smaller H1 */
        h2 {
            font-size: 15pt;
            border-bottom: 1px solid ${ReportConfig.colors.border}; /* Lighter border */
            padding-bottom: 0.4rem;
            padding-top: 1.5rem; /* Reduced top padding */
            margin-bottom: 1rem;
            color: ${ReportConfig.colors.primary}; /* Highlight section titles */
        }
        h3 { font-size: 12pt; margin-bottom: 0.75rem; color: ${ReportConfig.colors.textSecondary}; }
        h4 { font-size: 11pt; margin-bottom: 0.5rem; }

        .section { break-inside: avoid-page; margin-bottom: 1.5rem; } /* Ensures sections stay together */

        .report-header {
            display: flex; justify-content: space-between; align-items: flex-start;
            padding-bottom: 1rem; border-bottom: 2px solid ${ReportConfig.colors.primary}; margin-bottom: 1.5rem;
        }
        .report-header .title-block { max-width: 65%; }
        .report-header .brand { font-weight: 700; color: ${ReportConfig.colors.primary}; font-size: 11pt; }
        .report-header .meta-block { text-align: right; font-size: 9pt; color: ${ReportConfig.colors.textMuted}; }
        .meta-block strong { color: ${ReportConfig.colors.textSecondary}; }
        .meta-block > div { margin-bottom: 0.15rem; }

        .summary-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-top: 1rem; } /* 3 columns */
        .summary-card {
            background-color: ${ReportConfig.colors.background}; border: 1px solid ${ReportConfig.colors.border};
            border-top: 3px solid; border-radius: 6px; padding: 1rem; text-align: center;
        }
        .summary-card .label { font-size: 9pt; font-weight: 500; color: ${ReportConfig.colors.textMuted}; margin-bottom: 0.4rem; }
        .summary-card .value { font-size: 18pt; font-weight: 700; line-height: 1.2; }
        .summary-card.overall { grid-column: 1 / -1; border-top-color: ${ReportConfig.colors.primary}; padding: 1.25rem; }
        .summary-card.overall .label { font-size: 10pt; }
        .summary-card.overall .value { color: ${ReportConfig.colors.primary}; font-size: 20pt; }
        .summary-card.authentic { border-top-color: ${ReportConfig.colors.authentic}; }
        .summary-card.authentic .value { color: ${ReportConfig.colors.authentic}; }
        .summary-card.deepfake { border-top-color: ${ReportConfig.colors.deepfake}; }
        .summary-card.deepfake .value { color: ${ReportConfig.colors.deepfake}; }

        .details-table { width: 100%; border-collapse: collapse; margin-top: 0.8rem; font-size: 10pt; }
        .details-table td { padding: 0.5rem 0; border-bottom: 1px solid ${ReportConfig.colors.border}; vertical-align: top; }
        .details-table tr:last-child td { border-bottom: none; }
        .details-table .property-cell { font-weight: 500; color: ${ReportConfig.colors.textSecondary}; width: 28%; }
        .details-table .value-cell { color: ${ReportConfig.colors.textPrimary}; }

        .analysis-card {
            border: 1px solid ${ReportConfig.colors.border}; border-radius: 6px;
            margin-bottom: 1rem; break-inside: avoid-page; overflow: hidden;
            background-color: ${ReportConfig.colors.background};
        }
        .analysis-card-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 0.8rem 1rem; background-color: ${ReportConfig.colors.pageBackground}; /* Lighter header */
            border-bottom: 1px solid ${ReportConfig.colors.border};
        }
        .analysis-card-header .model-name { font-size: 11pt; font-weight: 600; }
        .prediction-badge { padding: 0.3rem 0.8rem; border-radius: 999px; font-weight: 600; color: white; font-size: 8pt; }
        .prediction-badge.real { background-color: ${ReportConfig.colors.authentic}; }
        .prediction-badge.fake { background-color: ${ReportConfig.colors.deepfake}; }
        .prediction-badge.failed { background-color: ${ReportConfig.colors.deepfake}; } /* For failed analyses */

        .analysis-card-body { padding: 1rem; }
        .analysis-card-body .confidence-display { text-align: center; margin-bottom: 0.8rem; }
        .analysis-card-body .confidence-display .label { font-size: 9pt; color: ${ReportConfig.colors.textMuted}; margin-bottom: 0.15rem; }
        .analysis-card-body .confidence-display .value { font-size: 28pt; font-weight: 700; line-height: 1; }
        .analysis-card-body .confidence-display .value.real { color: ${ReportConfig.colors.authentic}; }
        .analysis-card-body .confidence-display .value.fake { color: ${ReportConfig.colors.deepfake}; }
        .analysis-card-body .confidence-display .value.failed { color: ${ReportConfig.colors.deepfake}; }

        .analysis-card-body .error-message { color: ${ReportConfig.colors.deepfake}; font-size: 9pt; text-align: center; margin-top: 0.5rem; }


        .no-analysis-placeholder {
            text-align: center; padding: 3rem 1.5rem; background-color: ${ReportConfig.colors.background};
            border: 1px dashed ${ReportConfig.colors.border}; border-radius: 6px; color: ${ReportConfig.colors.textMuted};
        }

        .report-footer {
            margin-top: auto;
            padding-top: 1rem;
            border-top: 1px solid ${ReportConfig.colors.border};
            text-align: center; font-size: 8pt; color: ${ReportConfig.colors.textMuted};
            display: flex; justify-content: space-between;
        }

        @media print {
            body { background-color: white; padding: 0; display: block; }
            .page { box-shadow: none; margin: 0; padding: 15mm 16mm; min-height: 0; }
        }
    </style>
`;

//================================================================================================
// HTML COMPONENT RENDERERS
//================================================================================================

const renderHeader = (data) => `
    <div class="report-header">
        <div class="title-block">
            <div class="brand">${ReportConfig.brandName}</div>
            <h1>${ReportConfig.mainTitle}</h1>
            <div>${data.mediaType} File: ${data.filename}</div>
            ${
              data.url
                ? `<div><a href="${data.url.replace(
                    "/upload/",
                    "/upload/f_auto,q_auto/"
                  )}" style="font-size: 9pt; color: ${
                    ReportConfig.colors.primary
                  }; text-decoration: none;">View Original Media (Online)</a></div>`
                : ""
            }
        </div>
        <div class="meta-block">
            <div><strong>Report Date:</strong> ${formatDate(new Date())}</div>
            ${
              data.user
                ? `
                <div style="margin-top: 0.5rem;"><strong>Generated By:</strong></div>
                <div>${data.user.firstName || "N/A"} ${
                    data.user.lastName || ""
                  }</div>
                <div style="font-size: 8pt;">(${data.user.email || "N/A"})</div>
            `
                : ""
            }
            <div style="margin-top: 0.5rem;"><strong>Media ID:</strong> ${
              data.id
            }</div>
        </div>
    </div>
`;

const renderSummary = (data) => `
    <div class="section">
        <h2>${ReportConfig.icons.summary} Executive Summary</h2>
        <div class="summary-grid">
            <div class="summary-card overall">
                <div class="label">Overall Assessment</div>
                <div class="value">${data.overallAssessment}</div>
            </div>
            <div class="summary-card authentic">
                <div class="label">Authentic Detections</div>
                <div class="value">${data.realDetections}</div>
            </div>
            <div class="summary-card deepfake">
                <div class="label">Deepfake Detections</div>
                <div class="value">${data.fakeDetections}</div>
            </div>
             <div class="summary-card">
                <div class="label">Total Models Run</div>
                <div class="value">${
                  data.completedAnalyses.length + data.failedAnalyses.length
                }</div>
            </div>
             <div class="summary-card">
                <div class="label">Latest Run Status</div>
                <div class="value" style="color: ${
                  data.latestAnalysisRun?.status === "FAILED"
                    ? ReportConfig.colors.deepfake
                    : ReportConfig.colors.primary
                };">${data.latestAnalysisRun?.status || "N/A"}</div>
            </div>
             <div class="summary-card">
                <div class="label">Upload Date</div>
                <div class="value">${formatDate(data.createdAt)}</div>
            </div>
        </div>
    </div>
`;

const renderMediaInfo = (data) => `
    <div class="section">
        <h2>${ReportConfig.icons.info} Media Information</h2>
        <table class="details-table">
            <tbody>
                <tr><td class="property-cell">Filename</td><td class="value-cell">${
                  data.filename
                }</td></tr>
                <tr><td class="property-cell">Media Type</td><td class="value-cell">${
                  data.mediaType
                }</td></tr>
                <tr><td class="property-cell">File Size</td><td class="value-cell">${formatBytes(
                  data.size
                )}</td></tr>
                <tr><td class="property-cell">MIME Type</td><td class="value-cell">${
                  data.mimetype || "N/A"
                }</td></tr>
                <tr><td class="property-cell">Upload Date</td><td class="value-cell">${formatDate(
                  data.createdAt
                )}</td></tr>
                <tr><td class="property-cell">Current Status</td><td class="value-cell">${
                  data.status
                }</td></tr>
                ${
                  data.description
                    ? `<tr><td class="property-cell">Description</td><td class="value-cell">${data.description}</td></tr>`
                    : ""
                }
            </tbody>
        </table>
    </div>
`;

const renderAnalysisCard = (analysis) => {
  // Access prediction, confidence, processingTime from resultPayload
  const resultPayload = analysis.resultPayload || {};
  const prediction = analysis.prediction; // Use top-level prediction for simplicity
  const confidence = analysis.confidence; // Use top-level confidence
  const processingTime =
    resultPayload.processing_time || resultPayload.processingTime || null; // Backend might use different keys

  const isReal = prediction === "REAL";
  const isFailed = analysis.status === "FAILED";
  const confidenceDisplay = isFailed
    ? "N/A"
    : `${(confidence * 100).toFixed(1)}%`;
  const badgeClass = isFailed ? "failed" : isReal ? "real" : "fake";
  const valueClass = isFailed ? "failed" : isReal ? "real" : "fake";

  return `
        <div class="analysis-card">
            <div class="analysis-card-header">
                <div class="model-name">${analysis.modelName}</div>
                <div class="prediction-badge ${badgeClass}">
                    ${isFailed ? "Failed" : isReal ? "Authentic" : "Deepfake"}
                </div>
            </div>
            <div class="analysis-card-body">
                <div class="confidence-display">
                    <div class="label">Confidence Score</div>
                    <div class="value ${valueClass}">${confidenceDisplay}</div>
                </div>
                ${
                  isFailed
                    ? `
                    <p class="error-message">${ReportConfig.icons.error} ${
                        analysis.errorMessage || "Analysis failed unexpectedly."
                      }</p>
                `
                    : `
                    <table class="details-table">
                        <tr><td class="property-cell">Prediction</td><td class="value-cell">${prediction}</td></tr>
                        <tr><td class="property-cell">Analysis Date</td><td class="value-cell">${formatDate(
                          analysis.createdAt
                        )}</td></tr>
                        <tr><td class="property-cell">Processing Time</td><td class="value-cell">${formatProcessingTime(
                          processingTime
                        )}</td></tr>
                    </table>
                `
                }
            </div>
        </div>
    `;
};

const renderDetailedAnalyses = (data) => {
  if (
    !data.latestAnalysisRun ||
    (data.completedAnalyses.length === 0 && data.failedAnalyses.length === 0)
  ) {
    return renderNoAnalysesPlaceholder(data.latestAnalysisRun?.status);
  }

  const allAnalyses = [...data.completedAnalyses, ...data.failedAnalyses].sort(
    (a, b) => new Date(a.createdAt) - new Date(b.createdAt)
  );

  return `
        <div class="section">
            <h2>${ReportConfig.icons.details} Detailed Analysis Results (Run #${
    data.latestAnalysisRun.runNumber
  })</h2>
            ${allAnalyses.map(renderAnalysisCard).join("")}
        </div>
    `;
};

const renderNoAnalysesPlaceholder = (status) => {
  let message = "This media is pending analysis or could not be processed.";
  if (status === "QUEUED")
    message = "This media is queued and awaiting analysis.";
  if (status === "PROCESSING") message = "Analysis is currently in progress.";
  if (status === "FAILED") message = "The analysis run failed to complete.";

  return `
        <div class="section">
            <h2>${ReportConfig.icons.details} Analysis Results</h2>
            <div class="no-analysis-placeholder">
                <h3>No Analysis Completed</h3>
                <p>${message}</p>
            </div>
        </div>
    `;
};

const renderFooter = (pageNumber, mediaId) => `
    <div class="report-footer">
        <span>${ReportConfig.brandName} - Media Analysis Report</span>
        <span>Page ${pageNumber} of {totalPages}</span>
        <span>Media ID: ${mediaId}</span>
    </div>
`;

//================================================================================================
// MAIN HTML GENERATOR
//================================================================================================

const generateReportHTML = (media, user) => {
  const data = prepareReportData(media, user);

  let htmlPages = [];

  // Page 1: Header, Executive Summary, Media Information
  htmlPages.push(`
        <div class="page" style="display: flex; flex-direction: column;">
            ${renderHeader(data)}
            ${renderSummary(data)}
            ${renderMediaInfo(data)}
            <div class="report-footer">
                <span>${ReportConfig.brandName} - Media Analysis Report</span>
                <span>Page 1 of {totalPages}</span>
                <span>Media ID: ${data.id}</span>
            </div>
        </div>
    `);

  // Page 2 (if analyses exist): Detailed Analyses
  if (
    data.latestAnalysisRun &&
    (data.completedAnalyses.length > 0 || data.failedAnalyses.length > 0)
  ) {
    htmlPages.push(`
            <div class="page" style="display: flex; flex-direction: column;">
                ${renderDetailedAnalyses(data)}
                <div class="report-footer">
                    <span>${
                      ReportConfig.brandName
                    } - Media Analysis Report</span>
                    <span>Page 2 of {totalPages}</span>
                    <span>Media ID: ${data.id}</span>
                </div>
            </div>
        `);
  }

  const finalHtml = `
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>${ReportConfig.mainTitle} - ${data.filename}</title>
            ${getReportStyles()}
        </head>
        <body>
            ${htmlPages.join("")}
        </body>
        </html>
    `;

  return finalHtml.replace(/{totalPages}/g, htmlPages.length); // Replace placeholder
};

//================================================================================================
// PUBLIC API (EXPORTED SERVICE)
//================================================================================================

export const DownloadService = {
  async generateAndDownloadPDF(media, user) {
    try {
      const htmlContent = generateReportHTML(media, user);
      const element = document.createElement("div");
      element.innerHTML = htmlContent; // Use innerHTML to parse HTML string
      const bodyContent = element.querySelector("body");

      const options = {
        margin: [0, 0, 0, 0], // Margins set in CSS now
        filename: `${media.filename.replace(/\.[^/.]+$/, "")}_report.pdf`,
        image: { type: "jpeg", quality: 0.98 },
        html2canvas: {
          scale: 2, // Higher scale for better resolution
          useCORS: true,
          letterRendering: true,
          // Remove backgroundColor from html2canvas if body has it
          // backgroundColor: null,
        },
        jsPDF: { unit: "mm", format: "a4", orientation: "portrait" },
        // Enable multi-page rendering for html2pdf
        pagebreak: { mode: ["css", "legacy"] }, // Respect CSS page-break properties first
      };

      showToast.loading("Generating PDF report...", {
        id: "pdf-gen-toast",
        duration: Infinity,
      });
      await html2pdf().from(bodyContent).set(options).save();
      showToast.success("PDF report generated successfully!", {
        id: "pdf-gen-toast",
      });
    } catch (error) {
      console.error("Error generating PDF with html2pdf:", error);
      showToast.error("Failed to generate PDF report. Trying print view...", {
        id: "pdf-gen-toast",
      });
      // Fallback to print dialog if html2pdf fails
      await this.generateAndDownloadPDFPrint(media, user);
    }
  },

  async generateAndDownloadPDFPrint(media, user) {
    try {
      const htmlContent = generateReportHTML(media, user);
      const printWindow = window.open("", "_blank");
      if (!printWindow) {
        showToast.error(
          "Popup blocked. Please allow popups to generate the report.",
          { id: "pdf-gen-toast" }
        );
        throw new Error("Popup blocked by browser.");
      }
      printWindow.document.write(htmlContent);
      printWindow.document.close();
      // Allow a brief moment for the browser to render the content before printing
      setTimeout(() => {
        printWindow.focus();
        printWindow.print();
        setTimeout(() => {
          if (!printWindow.closed) printWindow.close();
        }, 2000); // Close after 2 seconds if not already
      }, 750); // Give browser 750ms to render
      showToast.success("Report opened in print view. Please print to PDF.", {
        id: "pdf-gen-toast",
      });
    } catch (error) {
      console.error("Error generating PDF via print dialog:", error);
      showToast.error(`Failed to generate PDF report: ${error.message}`, {
        id: "pdf-gen-toast",
      });
    }
  },

  async downloadMedia(mediaUrl, filename) {
    try {
      if (!mediaUrl) {
        showToast.error("Media URL is missing for download.");
        throw new Error("Media URL is missing.");
      }

      // Assume Cloudinary URL based on file structure
      const url = new URL(mediaUrl);
      const parts = url.pathname.split("/upload/");

      if (parts.length > 1) {
        // Ensure we get the full public ID which includes subfolders and original filename base
        const publicIdPath = parts[1].split("/").slice(1).join("/"); // Remove 'f_auto,q_auto' or similar
        const baseCloudinaryPath = parts[0];

        // Construct the new download URL with fl_attachment and f_auto (for optimal format conversion)
        const newPathname = `${baseCloudinaryPath}/upload/fl_attachment/${publicIdPath}`;
        url.pathname = newPathname;
      } else {
        // For non-Cloudinary or local paths, attempt direct download
        console.warn(
          "Non-Cloudinary URL structure detected for download. Attempting direct download."
        );
        // Simply use the provided URL if it's not a Cloudinary transformed URL
      }

      const link = document.createElement("a");
      link.href = url.href;
      link.download = filename || "download_file"; // Ensure filename is provided or default
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      showToast.success(`Downloading "${filename}"...`);
    } catch (error) {
      console.error("Error preparing media download:", error);
      showToast.error(`Failed to download media: ${error.message}`);
    }
  },

  async downloadHTMLReport(media, user) {
    try {
      const htmlContent = generateReportHTML(media, user);
      const blob = new Blob([htmlContent], { type: "text/html;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = `${media.filename.replace(
        /\.[^/.]+$/,
        ""
      )}_analysis_report.html`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      showToast.success("HTML report downloaded successfully!");
    } catch (error) {
      console.error("Error downloading HTML report:", error);
      showToast.error(`Failed to generate HTML report: ${error.message}`);
    }
  },
};
